/*
StackState API

StackState's API specification

API version: 0.0.1
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type EventApi interface {

	/*
	GetEvent Get single event

	Retrieves a specific event by its identifier.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param eventId The Identifier of an event.
	 @return ApiGetEventRequest
	*/
	GetEvent(ctx _context.Context, eventId string) ApiGetEventRequest

	// GetEventExecute executes the request
	//  @return TopologyEvent
	GetEventExecute(r ApiGetEventRequest) (TopologyEvent, *_nethttp.Response, error)

	/*
	GetEventSources Get event sources

	Get a list of event sources.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetEventSourcesRequest
	*/
	GetEventSources(ctx _context.Context) ApiGetEventSourcesRequest

	// GetEventSourcesExecute executes the request
	//  @return StringItemsWithTotal
	GetEventSourcesExecute(r ApiGetEventSourcesRequest) (StringItemsWithTotal, *_nethttp.Response, error)

	/*
	GetEventTags Get event tags

	Gets a list of tags that exist in a list of events.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetEventTagsRequest
	*/
	GetEventTags(ctx _context.Context) ApiGetEventTagsRequest

	// GetEventTagsExecute executes the request
	//  @return StringItemsWithTotal
	GetEventTagsExecute(r ApiGetEventTagsRequest) (StringItemsWithTotal, *_nethttp.Response, error)

	/*
	GetEventTypes Get event types

	Get a list of event types for a certain STQL query.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetEventTypesRequest
	*/
	GetEventTypes(ctx _context.Context) ApiGetEventTypesRequest

	// GetEventTypesExecute executes the request
	//  @return StringItemsWithTotal
	GetEventTypesExecute(r ApiGetEventTypesRequest) (StringItemsWithTotal, *_nethttp.Response, error)

	/*
	GetEvents Get events

	Gets you a list of events that exist for topology and time selections.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetEventsRequest
	*/
	GetEvents(ctx _context.Context) ApiGetEventsRequest

	// GetEventsExecute executes the request
	//  @return EventItemsWithTotal
	GetEventsExecute(r ApiGetEventsRequest) (EventItemsWithTotal, *_nethttp.Response, error)
}

// EventApiService EventApi service
type EventApiService service

type ApiGetEventRequest struct {
	ctx _context.Context
	ApiService EventApi
	eventId string
	startTimestampMs *int32
	endTimestampMs *int32
	playHeadTimestampMs *int32
}

func (r ApiGetEventRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}
func (r ApiGetEventRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}
func (r ApiGetEventRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}

func (r ApiGetEventRequest) Execute() (TopologyEvent, *_nethttp.Response, error) {
	return r.ApiService.GetEventExecute(r)
}

/*
GetEvent Get single event

Retrieves a specific event by its identifier.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId The Identifier of an event.
 @return ApiGetEventRequest
*/
func (a *EventApiService) GetEvent(ctx _context.Context, eventId string) ApiGetEventRequest {
	return ApiGetEventRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return TopologyEvent
func (a *EventApiService) GetEventExecute(r ApiGetEventRequest) (TopologyEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TopologyEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEvent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v EventNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v EventsError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventSourcesRequest struct {
	ctx _context.Context
	ApiService EventApi
	startTimestampMs *int32
	endTimestampMs *int32
	topologyQuery *string
	limit *int32
	rootCauseMode *RootCauseMode
	playHeadTimestampMs *int32
	eventTypes *[]string
	eventCategories *[]EventCategory
	eventSources *[]string
	eventTags *[]string
	match *string
}

func (r ApiGetEventSourcesRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventSourcesRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}
func (r ApiGetEventSourcesRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventSourcesRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}
func (r ApiGetEventSourcesRequest) TopologyQuery(topologyQuery string) ApiGetEventSourcesRequest {
	r.topologyQuery = &topologyQuery
	return r
}
func (r ApiGetEventSourcesRequest) Limit(limit int32) ApiGetEventSourcesRequest {
	r.limit = &limit
	return r
}
func (r ApiGetEventSourcesRequest) RootCauseMode(rootCauseMode RootCauseMode) ApiGetEventSourcesRequest {
	r.rootCauseMode = &rootCauseMode
	return r
}
func (r ApiGetEventSourcesRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventSourcesRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}
func (r ApiGetEventSourcesRequest) EventTypes(eventTypes []string) ApiGetEventSourcesRequest {
	r.eventTypes = &eventTypes
	return r
}
// The category labels of an event.
func (r ApiGetEventSourcesRequest) EventCategories(eventCategories []EventCategory) ApiGetEventSourcesRequest {
	r.eventCategories = &eventCategories
	return r
}
func (r ApiGetEventSourcesRequest) EventSources(eventSources []string) ApiGetEventSourcesRequest {
	r.eventSources = &eventSources
	return r
}
func (r ApiGetEventSourcesRequest) EventTags(eventTags []string) ApiGetEventSourcesRequest {
	r.eventTags = &eventTags
	return r
}
func (r ApiGetEventSourcesRequest) Match(match string) ApiGetEventSourcesRequest {
	r.match = &match
	return r
}

func (r ApiGetEventSourcesRequest) Execute() (StringItemsWithTotal, *_nethttp.Response, error) {
	return r.ApiService.GetEventSourcesExecute(r)
}

/*
GetEventSources Get event sources

Get a list of event sources.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventSourcesRequest
*/
func (a *EventApiService) GetEventSources(ctx _context.Context) ApiGetEventSourcesRequest {
	return ApiGetEventSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StringItemsWithTotal
func (a *EventApiService) GetEventSourcesExecute(r ApiGetEventSourcesRequest) (StringItemsWithTotal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StringItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEventSources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventSources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}
	if r.topologyQuery == nil {
		return localVarReturnValue, nil, reportError("topologyQuery is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	localVarQueryParams.Add("topologyQuery", parameterToString(*r.topologyQuery, ""))
	if r.rootCauseMode != nil {
		localVarQueryParams.Add("rootCauseMode", parameterToString(*r.rootCauseMode, ""))
	}
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	if r.eventTypes != nil {
		localVarQueryParams.Add("eventTypes", parameterToString(*r.eventTypes, "pipes"))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.eventCategories != nil {
		localVarQueryParams.Add("eventCategories", parameterToString(*r.eventCategories, "pipes"))
	}
	if r.eventSources != nil {
		localVarQueryParams.Add("eventSources", parameterToString(*r.eventSources, "pipes"))
	}
	if r.eventTags != nil {
		localVarQueryParams.Add("eventTags", parameterToString(*r.eventTags, "pipes"))
	}
	if r.match != nil {
		localVarQueryParams.Add("match", parameterToString(*r.match, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v EventsError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TopologyOverflowError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventTagsRequest struct {
	ctx _context.Context
	ApiService EventApi
	startTimestampMs *int32
	endTimestampMs *int32
	topologyQuery *string
	limit *int32
	rootCauseMode *RootCauseMode
	playHeadTimestampMs *int32
	eventTypes *[]string
	eventCategories *[]EventCategory
	eventSources *[]string
	eventTags *[]string
	match *string
}

func (r ApiGetEventTagsRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventTagsRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}
func (r ApiGetEventTagsRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventTagsRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}
func (r ApiGetEventTagsRequest) TopologyQuery(topologyQuery string) ApiGetEventTagsRequest {
	r.topologyQuery = &topologyQuery
	return r
}
func (r ApiGetEventTagsRequest) Limit(limit int32) ApiGetEventTagsRequest {
	r.limit = &limit
	return r
}
func (r ApiGetEventTagsRequest) RootCauseMode(rootCauseMode RootCauseMode) ApiGetEventTagsRequest {
	r.rootCauseMode = &rootCauseMode
	return r
}
func (r ApiGetEventTagsRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventTagsRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}
func (r ApiGetEventTagsRequest) EventTypes(eventTypes []string) ApiGetEventTagsRequest {
	r.eventTypes = &eventTypes
	return r
}
// The category labels of an event.
func (r ApiGetEventTagsRequest) EventCategories(eventCategories []EventCategory) ApiGetEventTagsRequest {
	r.eventCategories = &eventCategories
	return r
}
func (r ApiGetEventTagsRequest) EventSources(eventSources []string) ApiGetEventTagsRequest {
	r.eventSources = &eventSources
	return r
}
func (r ApiGetEventTagsRequest) EventTags(eventTags []string) ApiGetEventTagsRequest {
	r.eventTags = &eventTags
	return r
}
func (r ApiGetEventTagsRequest) Match(match string) ApiGetEventTagsRequest {
	r.match = &match
	return r
}

func (r ApiGetEventTagsRequest) Execute() (StringItemsWithTotal, *_nethttp.Response, error) {
	return r.ApiService.GetEventTagsExecute(r)
}

/*
GetEventTags Get event tags

Gets a list of tags that exist in a list of events.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventTagsRequest
*/
func (a *EventApiService) GetEventTags(ctx _context.Context) ApiGetEventTagsRequest {
	return ApiGetEventTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StringItemsWithTotal
func (a *EventApiService) GetEventTagsExecute(r ApiGetEventTagsRequest) (StringItemsWithTotal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StringItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEventTags")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventTags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}
	if r.topologyQuery == nil {
		return localVarReturnValue, nil, reportError("topologyQuery is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	localVarQueryParams.Add("topologyQuery", parameterToString(*r.topologyQuery, ""))
	if r.rootCauseMode != nil {
		localVarQueryParams.Add("rootCauseMode", parameterToString(*r.rootCauseMode, ""))
	}
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	if r.eventTypes != nil {
		localVarQueryParams.Add("eventTypes", parameterToString(*r.eventTypes, "pipes"))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.eventCategories != nil {
		localVarQueryParams.Add("eventCategories", parameterToString(*r.eventCategories, "pipes"))
	}
	if r.eventSources != nil {
		localVarQueryParams.Add("eventSources", parameterToString(*r.eventSources, "pipes"))
	}
	if r.eventTags != nil {
		localVarQueryParams.Add("eventTags", parameterToString(*r.eventTags, "pipes"))
	}
	if r.match != nil {
		localVarQueryParams.Add("match", parameterToString(*r.match, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v EventsError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TopologyOverflowError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventTypesRequest struct {
	ctx _context.Context
	ApiService EventApi
	startTimestampMs *int32
	endTimestampMs *int32
	topologyQuery *string
	limit *int32
	rootCauseMode *RootCauseMode
	playHeadTimestampMs *int32
	eventTypes *[]string
	eventCategories *[]EventCategory
	eventSources *[]string
	eventTags *[]string
	match *string
}

func (r ApiGetEventTypesRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventTypesRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}
func (r ApiGetEventTypesRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventTypesRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}
func (r ApiGetEventTypesRequest) TopologyQuery(topologyQuery string) ApiGetEventTypesRequest {
	r.topologyQuery = &topologyQuery
	return r
}
func (r ApiGetEventTypesRequest) Limit(limit int32) ApiGetEventTypesRequest {
	r.limit = &limit
	return r
}
func (r ApiGetEventTypesRequest) RootCauseMode(rootCauseMode RootCauseMode) ApiGetEventTypesRequest {
	r.rootCauseMode = &rootCauseMode
	return r
}
func (r ApiGetEventTypesRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventTypesRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}
func (r ApiGetEventTypesRequest) EventTypes(eventTypes []string) ApiGetEventTypesRequest {
	r.eventTypes = &eventTypes
	return r
}
// The category labels of an event.
func (r ApiGetEventTypesRequest) EventCategories(eventCategories []EventCategory) ApiGetEventTypesRequest {
	r.eventCategories = &eventCategories
	return r
}
func (r ApiGetEventTypesRequest) EventSources(eventSources []string) ApiGetEventTypesRequest {
	r.eventSources = &eventSources
	return r
}
func (r ApiGetEventTypesRequest) EventTags(eventTags []string) ApiGetEventTypesRequest {
	r.eventTags = &eventTags
	return r
}
func (r ApiGetEventTypesRequest) Match(match string) ApiGetEventTypesRequest {
	r.match = &match
	return r
}

func (r ApiGetEventTypesRequest) Execute() (StringItemsWithTotal, *_nethttp.Response, error) {
	return r.ApiService.GetEventTypesExecute(r)
}

/*
GetEventTypes Get event types

Get a list of event types for a certain STQL query.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventTypesRequest
*/
func (a *EventApiService) GetEventTypes(ctx _context.Context) ApiGetEventTypesRequest {
	return ApiGetEventTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StringItemsWithTotal
func (a *EventApiService) GetEventTypesExecute(r ApiGetEventTypesRequest) (StringItemsWithTotal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StringItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEventTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}
	if r.topologyQuery == nil {
		return localVarReturnValue, nil, reportError("topologyQuery is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	localVarQueryParams.Add("topologyQuery", parameterToString(*r.topologyQuery, ""))
	if r.rootCauseMode != nil {
		localVarQueryParams.Add("rootCauseMode", parameterToString(*r.rootCauseMode, ""))
	}
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	if r.eventTypes != nil {
		localVarQueryParams.Add("eventTypes", parameterToString(*r.eventTypes, "pipes"))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.eventCategories != nil {
		localVarQueryParams.Add("eventCategories", parameterToString(*r.eventCategories, "pipes"))
	}
	if r.eventSources != nil {
		localVarQueryParams.Add("eventSources", parameterToString(*r.eventSources, "pipes"))
	}
	if r.eventTags != nil {
		localVarQueryParams.Add("eventTags", parameterToString(*r.eventTags, "pipes"))
	}
	if r.match != nil {
		localVarQueryParams.Add("match", parameterToString(*r.match, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v EventsError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TopologyOverflowError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsRequest struct {
	ctx _context.Context
	ApiService EventApi
	eventListRequest *EventListRequest
}

func (r ApiGetEventsRequest) EventListRequest(eventListRequest EventListRequest) ApiGetEventsRequest {
	r.eventListRequest = &eventListRequest
	return r
}

func (r ApiGetEventsRequest) Execute() (EventItemsWithTotal, *_nethttp.Response, error) {
	return r.ApiService.GetEventsExecute(r)
}

/*
GetEvents Get events

Gets you a list of events that exist for topology and time selections.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventsRequest
*/
func (a *EventApiService) GetEvents(ctx _context.Context) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventItemsWithTotal
func (a *EventApiService) GetEventsExecute(r ApiGetEventsRequest) (EventItemsWithTotal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EventItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.eventListRequest == nil {
		return localVarReturnValue, nil, reportError("eventListRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventListRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v EventsError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TopologyOverflowError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
