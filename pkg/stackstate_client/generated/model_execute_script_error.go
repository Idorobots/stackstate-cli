/*
StackState API

StackState's API specification

API version: 0.0.1
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// ExecuteScriptError - struct for ExecuteScriptError
type ExecuteScriptError struct {
	ExecuteScriptArgumentsScriptError *ExecuteScriptArgumentsScriptError
	ExecuteScriptExceptionError *ExecuteScriptExceptionError
	ExecuteScriptExecutionError *ExecuteScriptExecutionError
	ExecuteScriptGroovyRuntimeError *ExecuteScriptGroovyRuntimeError
	ExecuteScriptSecurityError *ExecuteScriptSecurityError
	ExecuteScriptSyntaxErrors *ExecuteScriptSyntaxErrors
	ExecuteScriptTimeoutError *ExecuteScriptTimeoutError
	ExecuteScriptWrongReturnTypeError *ExecuteScriptWrongReturnTypeError
}

// ExecuteScriptArgumentsScriptErrorAsExecuteScriptError is a convenience function that returns ExecuteScriptArgumentsScriptError wrapped in ExecuteScriptError
func ExecuteScriptArgumentsScriptErrorAsExecuteScriptError(v *ExecuteScriptArgumentsScriptError) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptArgumentsScriptError: v}
}

// ExecuteScriptExceptionErrorAsExecuteScriptError is a convenience function that returns ExecuteScriptExceptionError wrapped in ExecuteScriptError
func ExecuteScriptExceptionErrorAsExecuteScriptError(v *ExecuteScriptExceptionError) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptExceptionError: v}
}

// ExecuteScriptExecutionErrorAsExecuteScriptError is a convenience function that returns ExecuteScriptExecutionError wrapped in ExecuteScriptError
func ExecuteScriptExecutionErrorAsExecuteScriptError(v *ExecuteScriptExecutionError) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptExecutionError: v}
}

// ExecuteScriptGroovyRuntimeErrorAsExecuteScriptError is a convenience function that returns ExecuteScriptGroovyRuntimeError wrapped in ExecuteScriptError
func ExecuteScriptGroovyRuntimeErrorAsExecuteScriptError(v *ExecuteScriptGroovyRuntimeError) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptGroovyRuntimeError: v}
}

// ExecuteScriptSecurityErrorAsExecuteScriptError is a convenience function that returns ExecuteScriptSecurityError wrapped in ExecuteScriptError
func ExecuteScriptSecurityErrorAsExecuteScriptError(v *ExecuteScriptSecurityError) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptSecurityError: v}
}

// ExecuteScriptSyntaxErrorsAsExecuteScriptError is a convenience function that returns ExecuteScriptSyntaxErrors wrapped in ExecuteScriptError
func ExecuteScriptSyntaxErrorsAsExecuteScriptError(v *ExecuteScriptSyntaxErrors) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptSyntaxErrors: v}
}

// ExecuteScriptTimeoutErrorAsExecuteScriptError is a convenience function that returns ExecuteScriptTimeoutError wrapped in ExecuteScriptError
func ExecuteScriptTimeoutErrorAsExecuteScriptError(v *ExecuteScriptTimeoutError) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptTimeoutError: v}
}

// ExecuteScriptWrongReturnTypeErrorAsExecuteScriptError is a convenience function that returns ExecuteScriptWrongReturnTypeError wrapped in ExecuteScriptError
func ExecuteScriptWrongReturnTypeErrorAsExecuteScriptError(v *ExecuteScriptWrongReturnTypeError) ExecuteScriptError {
	return ExecuteScriptError{ ExecuteScriptWrongReturnTypeError: v}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *ExecuteScriptError) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ExecuteScriptArgumentsScriptError
	err = json.Unmarshal(data, &dst.ExecuteScriptArgumentsScriptError)
	if err == nil {
		jsonExecuteScriptArgumentsScriptError, _ := json.Marshal(dst.ExecuteScriptArgumentsScriptError)
		if string(jsonExecuteScriptArgumentsScriptError) == "{}" { // empty struct
			dst.ExecuteScriptArgumentsScriptError = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptArgumentsScriptError = nil
	}

	// try to unmarshal data into ExecuteScriptExceptionError
	err = json.Unmarshal(data, &dst.ExecuteScriptExceptionError)
	if err == nil {
		jsonExecuteScriptExceptionError, _ := json.Marshal(dst.ExecuteScriptExceptionError)
		if string(jsonExecuteScriptExceptionError) == "{}" { // empty struct
			dst.ExecuteScriptExceptionError = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptExceptionError = nil
	}

	// try to unmarshal data into ExecuteScriptExecutionError
	err = json.Unmarshal(data, &dst.ExecuteScriptExecutionError)
	if err == nil {
		jsonExecuteScriptExecutionError, _ := json.Marshal(dst.ExecuteScriptExecutionError)
		if string(jsonExecuteScriptExecutionError) == "{}" { // empty struct
			dst.ExecuteScriptExecutionError = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptExecutionError = nil
	}

	// try to unmarshal data into ExecuteScriptGroovyRuntimeError
	err = json.Unmarshal(data, &dst.ExecuteScriptGroovyRuntimeError)
	if err == nil {
		jsonExecuteScriptGroovyRuntimeError, _ := json.Marshal(dst.ExecuteScriptGroovyRuntimeError)
		if string(jsonExecuteScriptGroovyRuntimeError) == "{}" { // empty struct
			dst.ExecuteScriptGroovyRuntimeError = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptGroovyRuntimeError = nil
	}

	// try to unmarshal data into ExecuteScriptSecurityError
	err = json.Unmarshal(data, &dst.ExecuteScriptSecurityError)
	if err == nil {
		jsonExecuteScriptSecurityError, _ := json.Marshal(dst.ExecuteScriptSecurityError)
		if string(jsonExecuteScriptSecurityError) == "{}" { // empty struct
			dst.ExecuteScriptSecurityError = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptSecurityError = nil
	}

	// try to unmarshal data into ExecuteScriptSyntaxErrors
	err = json.Unmarshal(data, &dst.ExecuteScriptSyntaxErrors)
	if err == nil {
		jsonExecuteScriptSyntaxErrors, _ := json.Marshal(dst.ExecuteScriptSyntaxErrors)
		if string(jsonExecuteScriptSyntaxErrors) == "{}" { // empty struct
			dst.ExecuteScriptSyntaxErrors = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptSyntaxErrors = nil
	}

	// try to unmarshal data into ExecuteScriptTimeoutError
	err = json.Unmarshal(data, &dst.ExecuteScriptTimeoutError)
	if err == nil {
		jsonExecuteScriptTimeoutError, _ := json.Marshal(dst.ExecuteScriptTimeoutError)
		if string(jsonExecuteScriptTimeoutError) == "{}" { // empty struct
			dst.ExecuteScriptTimeoutError = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptTimeoutError = nil
	}

	// try to unmarshal data into ExecuteScriptWrongReturnTypeError
	err = json.Unmarshal(data, &dst.ExecuteScriptWrongReturnTypeError)
	if err == nil {
		jsonExecuteScriptWrongReturnTypeError, _ := json.Marshal(dst.ExecuteScriptWrongReturnTypeError)
		if string(jsonExecuteScriptWrongReturnTypeError) == "{}" { // empty struct
			dst.ExecuteScriptWrongReturnTypeError = nil
		} else {
			match++
		}
	} else {
		dst.ExecuteScriptWrongReturnTypeError = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ExecuteScriptArgumentsScriptError = nil
		dst.ExecuteScriptExceptionError = nil
		dst.ExecuteScriptExecutionError = nil
		dst.ExecuteScriptGroovyRuntimeError = nil
		dst.ExecuteScriptSecurityError = nil
		dst.ExecuteScriptSyntaxErrors = nil
		dst.ExecuteScriptTimeoutError = nil
		dst.ExecuteScriptWrongReturnTypeError = nil

		return fmt.Errorf("Data matches more than one schema in oneOf(ExecuteScriptError)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("Data failed to match schemas in oneOf(ExecuteScriptError)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ExecuteScriptError) MarshalJSON() ([]byte, error) {
	if src.ExecuteScriptArgumentsScriptError != nil {
		return json.Marshal(&src.ExecuteScriptArgumentsScriptError)
	}

	if src.ExecuteScriptExceptionError != nil {
		return json.Marshal(&src.ExecuteScriptExceptionError)
	}

	if src.ExecuteScriptExecutionError != nil {
		return json.Marshal(&src.ExecuteScriptExecutionError)
	}

	if src.ExecuteScriptGroovyRuntimeError != nil {
		return json.Marshal(&src.ExecuteScriptGroovyRuntimeError)
	}

	if src.ExecuteScriptSecurityError != nil {
		return json.Marshal(&src.ExecuteScriptSecurityError)
	}

	if src.ExecuteScriptSyntaxErrors != nil {
		return json.Marshal(&src.ExecuteScriptSyntaxErrors)
	}

	if src.ExecuteScriptTimeoutError != nil {
		return json.Marshal(&src.ExecuteScriptTimeoutError)
	}

	if src.ExecuteScriptWrongReturnTypeError != nil {
		return json.Marshal(&src.ExecuteScriptWrongReturnTypeError)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ExecuteScriptError) GetActualInstance() (interface{}) {
	if obj.ExecuteScriptArgumentsScriptError != nil {
		return obj.ExecuteScriptArgumentsScriptError
	}

	if obj.ExecuteScriptExceptionError != nil {
		return obj.ExecuteScriptExceptionError
	}

	if obj.ExecuteScriptExecutionError != nil {
		return obj.ExecuteScriptExecutionError
	}

	if obj.ExecuteScriptGroovyRuntimeError != nil {
		return obj.ExecuteScriptGroovyRuntimeError
	}

	if obj.ExecuteScriptSecurityError != nil {
		return obj.ExecuteScriptSecurityError
	}

	if obj.ExecuteScriptSyntaxErrors != nil {
		return obj.ExecuteScriptSyntaxErrors
	}

	if obj.ExecuteScriptTimeoutError != nil {
		return obj.ExecuteScriptTimeoutError
	}

	if obj.ExecuteScriptWrongReturnTypeError != nil {
		return obj.ExecuteScriptWrongReturnTypeError
	}

	// all schemas are nil
	return nil
}

type NullableExecuteScriptError struct {
	value *ExecuteScriptError
	isSet bool
}

func (v NullableExecuteScriptError) Get() *ExecuteScriptError {
	return v.value
}

func (v *NullableExecuteScriptError) Set(val *ExecuteScriptError) {
	v.value = val
	v.isSet = true
}

func (v NullableExecuteScriptError) IsSet() bool {
	return v.isSet
}

func (v *NullableExecuteScriptError) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableExecuteScriptError(val *ExecuteScriptError) *NullableExecuteScriptError {
	return &NullableExecuteScriptError{value: val, isSet: true}
}

func (v NullableExecuteScriptError) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableExecuteScriptError) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


