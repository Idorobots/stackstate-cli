/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type ComponentApi interface {

	/*
		GetComponentCheck Get the check from the component

		Get a Specific check from the component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param componentId The Identifier of a component
		@param checkId The Identifier of a Check
		@return ApiGetComponentCheckRequest
	*/
	GetComponentCheck(ctx context.Context, componentId int64, checkId int64) ApiGetComponentCheckRequest

	// GetComponentCheckExecute executes the request
	//  @return Check
	GetComponentCheckExecute(r ApiGetComponentCheckRequest) (*Check, *http.Response, error)

	/*
		GetComponentChecks List all checks from the component

		List all checks from the component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param componentId The Identifier of a component
		@return ApiGetComponentChecksRequest
	*/
	GetComponentChecks(ctx context.Context, componentId int64) ApiGetComponentChecksRequest

	// GetComponentChecksExecute executes the request
	//  @return []Check
	GetComponentChecksExecute(r ApiGetComponentChecksRequest) ([]Check, *http.Response, error)

	/*
		GetComponentStream Get the stream from the component

		Get a Specific stream from the component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param componentId The Identifier of a component
		@param streamId The Identifier of a stream
		@return ApiGetComponentStreamRequest
	*/
	GetComponentStream(ctx context.Context, componentId int64, streamId int64) ApiGetComponentStreamRequest

	// GetComponentStreamExecute executes the request
	//  @return TelemetryStreamDefinition
	GetComponentStreamExecute(r ApiGetComponentStreamRequest) (*TelemetryStreamDefinition, *http.Response, error)

	/*
		GetComponentStreams List all streams from the component

		List all streams from the component

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param componentId The Identifier of a component
		@return ApiGetComponentStreamsRequest
	*/
	GetComponentStreams(ctx context.Context, componentId int64) ApiGetComponentStreamsRequest

	// GetComponentStreamsExecute executes the request
	//  @return []TelemetryStreamDefinition
	GetComponentStreamsExecute(r ApiGetComponentStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error)

	/*
		GetLatestMetrics Get the latests metrics

		Gets a top 3 metrics for a datapoint, always takes the last 15 minutes before provided timepoint

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param componentId The Identifier of a component
		@return ApiGetLatestMetricsRequest
	*/
	GetLatestMetrics(ctx context.Context, componentId int64) ApiGetLatestMetricsRequest

	// GetLatestMetricsExecute executes the request
	//  @return TelemetryLatestSnapshotsResponse
	GetLatestMetricsExecute(r ApiGetLatestMetricsRequest) (*TelemetryLatestSnapshotsResponse, *http.Response, error)
}

// ComponentApiService ComponentApi service
type ComponentApiService service

type ApiGetComponentCheckRequest struct {
	ctx         context.Context
	ApiService  ComponentApi
	componentId int64
	queryTime   *int32
	checkId     int64
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetComponentCheckRequest) QueryTime(queryTime int32) ApiGetComponentCheckRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetComponentCheckRequest) Execute() (*Check, *http.Response, error) {
	return r.ApiService.GetComponentCheckExecute(r)
}

/*
GetComponentCheck Get the check from the component

Get a Specific check from the component

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The Identifier of a component
 @param checkId The Identifier of a Check
 @return ApiGetComponentCheckRequest
*/
func (a *ComponentApiService) GetComponentCheck(ctx context.Context, componentId int64, checkId int64) ApiGetComponentCheckRequest {
	return ApiGetComponentCheckRequest{
		ApiService:  a,
		ctx:         ctx,
		componentId: componentId,
		checkId:     checkId,
	}
}

// Execute executes the request
//  @return Check
func (a *ComponentApiService) GetComponentCheckExecute(r ApiGetComponentCheckRequest) (*Check, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentApiService.GetComponentCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/components/{componentId}/checks/{checkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterToString(r.componentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"checkId"+"}", url.PathEscape(parameterToString(r.checkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComponentChecksRequest struct {
	ctx         context.Context
	ApiService  ComponentApi
	componentId int64
	queryTime   *int32
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetComponentChecksRequest) QueryTime(queryTime int32) ApiGetComponentChecksRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetComponentChecksRequest) Execute() ([]Check, *http.Response, error) {
	return r.ApiService.GetComponentChecksExecute(r)
}

/*
GetComponentChecks List all checks from the component

List all checks from the component

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The Identifier of a component
 @return ApiGetComponentChecksRequest
*/
func (a *ComponentApiService) GetComponentChecks(ctx context.Context, componentId int64) ApiGetComponentChecksRequest {
	return ApiGetComponentChecksRequest{
		ApiService:  a,
		ctx:         ctx,
		componentId: componentId,
	}
}

// Execute executes the request
//  @return []Check
func (a *ComponentApiService) GetComponentChecksExecute(r ApiGetComponentChecksRequest) ([]Check, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentApiService.GetComponentChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/components/{componentId}/checks"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterToString(r.componentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComponentStreamRequest struct {
	ctx         context.Context
	ApiService  ComponentApi
	componentId int64
	queryTime   *int32
	streamId    int64
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetComponentStreamRequest) QueryTime(queryTime int32) ApiGetComponentStreamRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetComponentStreamRequest) Execute() (*TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.GetComponentStreamExecute(r)
}

/*
GetComponentStream Get the stream from the component

Get a Specific stream from the component

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The Identifier of a component
 @param streamId The Identifier of a stream
 @return ApiGetComponentStreamRequest
*/
func (a *ComponentApiService) GetComponentStream(ctx context.Context, componentId int64, streamId int64) ApiGetComponentStreamRequest {
	return ApiGetComponentStreamRequest{
		ApiService:  a,
		ctx:         ctx,
		componentId: componentId,
		streamId:    streamId,
	}
}

// Execute executes the request
//  @return TelemetryStreamDefinition
func (a *ComponentApiService) GetComponentStreamExecute(r ApiGetComponentStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentApiService.GetComponentStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/components/{componentId}/streams/{streamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterToString(r.componentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComponentStreamsRequest struct {
	ctx         context.Context
	ApiService  ComponentApi
	componentId int64
	queryTime   *int32
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetComponentStreamsRequest) QueryTime(queryTime int32) ApiGetComponentStreamsRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetComponentStreamsRequest) Execute() ([]TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.GetComponentStreamsExecute(r)
}

/*
GetComponentStreams List all streams from the component

List all streams from the component

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The Identifier of a component
 @return ApiGetComponentStreamsRequest
*/
func (a *ComponentApiService) GetComponentStreams(ctx context.Context, componentId int64) ApiGetComponentStreamsRequest {
	return ApiGetComponentStreamsRequest{
		ApiService:  a,
		ctx:         ctx,
		componentId: componentId,
	}
}

// Execute executes the request
//  @return []TelemetryStreamDefinition
func (a *ComponentApiService) GetComponentStreamsExecute(r ApiGetComponentStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentApiService.GetComponentStreams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/components/{componentId}/streams"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterToString(r.componentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestMetricsRequest struct {
	ctx         context.Context
	ApiService  ComponentApi
	componentId int64
	queryTime   *int32
	streamIds   *[]int64
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetLatestMetricsRequest) QueryTime(queryTime int32) ApiGetLatestMetricsRequest {
	r.queryTime = &queryTime
	return r
}

// Ids of streams to query for
func (r ApiGetLatestMetricsRequest) StreamIds(streamIds []int64) ApiGetLatestMetricsRequest {
	r.streamIds = &streamIds
	return r
}

func (r ApiGetLatestMetricsRequest) Execute() (*TelemetryLatestSnapshotsResponse, *http.Response, error) {
	return r.ApiService.GetLatestMetricsExecute(r)
}

/*
GetLatestMetrics Get the latests metrics

Gets a top 3 metrics for a datapoint, always takes the last 15 minutes before provided timepoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The Identifier of a component
 @return ApiGetLatestMetricsRequest
*/
func (a *ComponentApiService) GetLatestMetrics(ctx context.Context, componentId int64) ApiGetLatestMetricsRequest {
	return ApiGetLatestMetricsRequest{
		ApiService:  a,
		ctx:         ctx,
		componentId: componentId,
	}
}

// Execute executes the request
//  @return TelemetryLatestSnapshotsResponse
func (a *ComponentApiService) GetLatestMetricsExecute(r ApiGetLatestMetricsRequest) (*TelemetryLatestSnapshotsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TelemetryLatestSnapshotsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentApiService.GetLatestMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/components/{componentId}/streams/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterToString(r.componentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}
	if r.streamIds == nil {
		return localVarReturnValue, nil, reportError("streamIds is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	localVarQueryParams.Add("streamIds", parameterToString(*r.streamIds, "csv"))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ComponentNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type ComponentApiMock struct {
	GetComponentCheckCalls      *[]GetComponentCheckCall
	GetComponentCheckResponse   GetComponentCheckMockResponse
	GetComponentChecksCalls     *[]GetComponentChecksCall
	GetComponentChecksResponse  GetComponentChecksMockResponse
	GetComponentStreamCalls     *[]GetComponentStreamCall
	GetComponentStreamResponse  GetComponentStreamMockResponse
	GetComponentStreamsCalls    *[]GetComponentStreamsCall
	GetComponentStreamsResponse GetComponentStreamsMockResponse
	GetLatestMetricsCalls       *[]GetLatestMetricsCall
	GetLatestMetricsResponse    GetLatestMetricsMockResponse
}

func NewComponentApiMock() ComponentApiMock {
	xGetComponentCheckCalls := make([]GetComponentCheckCall, 0)
	xGetComponentChecksCalls := make([]GetComponentChecksCall, 0)
	xGetComponentStreamCalls := make([]GetComponentStreamCall, 0)
	xGetComponentStreamsCalls := make([]GetComponentStreamsCall, 0)
	xGetLatestMetricsCalls := make([]GetLatestMetricsCall, 0)
	return ComponentApiMock{
		GetComponentCheckCalls:   &xGetComponentCheckCalls,
		GetComponentChecksCalls:  &xGetComponentChecksCalls,
		GetComponentStreamCalls:  &xGetComponentStreamCalls,
		GetComponentStreamsCalls: &xGetComponentStreamsCalls,
		GetLatestMetricsCalls:    &xGetLatestMetricsCalls,
	}
}

type GetComponentCheckMockResponse struct {
	Result   Check
	Response *http.Response
	Error    error
}

type GetComponentCheckCall struct {
	PcomponentId int64
	PqueryTime   *int32
	PcheckId     int64
}

func (mock ComponentApiMock) GetComponentCheck(ctx context.Context, componentId int64, checkId int64) ApiGetComponentCheckRequest {
	return ApiGetComponentCheckRequest{
		ApiService:  mock,
		ctx:         ctx,
		componentId: componentId,
		checkId:     checkId,
	}
}

func (mock ComponentApiMock) GetComponentCheckExecute(r ApiGetComponentCheckRequest) (*Check, *http.Response, error) {
	p := GetComponentCheckCall{
		PcomponentId: r.componentId,
		PqueryTime:   r.queryTime,
		PcheckId:     r.checkId,
	}
	*mock.GetComponentCheckCalls = append(*mock.GetComponentCheckCalls, p)
	return &mock.GetComponentCheckResponse.Result, mock.GetComponentCheckResponse.Response, mock.GetComponentCheckResponse.Error
}

type GetComponentChecksMockResponse struct {
	Result   []Check
	Response *http.Response
	Error    error
}

type GetComponentChecksCall struct {
	PcomponentId int64
	PqueryTime   *int32
}

func (mock ComponentApiMock) GetComponentChecks(ctx context.Context, componentId int64) ApiGetComponentChecksRequest {
	return ApiGetComponentChecksRequest{
		ApiService:  mock,
		ctx:         ctx,
		componentId: componentId,
	}
}

func (mock ComponentApiMock) GetComponentChecksExecute(r ApiGetComponentChecksRequest) ([]Check, *http.Response, error) {
	p := GetComponentChecksCall{
		PcomponentId: r.componentId,
		PqueryTime:   r.queryTime,
	}
	*mock.GetComponentChecksCalls = append(*mock.GetComponentChecksCalls, p)
	return mock.GetComponentChecksResponse.Result, mock.GetComponentChecksResponse.Response, mock.GetComponentChecksResponse.Error
}

type GetComponentStreamMockResponse struct {
	Result   TelemetryStreamDefinition
	Response *http.Response
	Error    error
}

type GetComponentStreamCall struct {
	PcomponentId int64
	PqueryTime   *int32
	PstreamId    int64
}

func (mock ComponentApiMock) GetComponentStream(ctx context.Context, componentId int64, streamId int64) ApiGetComponentStreamRequest {
	return ApiGetComponentStreamRequest{
		ApiService:  mock,
		ctx:         ctx,
		componentId: componentId,
		streamId:    streamId,
	}
}

func (mock ComponentApiMock) GetComponentStreamExecute(r ApiGetComponentStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	p := GetComponentStreamCall{
		PcomponentId: r.componentId,
		PqueryTime:   r.queryTime,
		PstreamId:    r.streamId,
	}
	*mock.GetComponentStreamCalls = append(*mock.GetComponentStreamCalls, p)
	return &mock.GetComponentStreamResponse.Result, mock.GetComponentStreamResponse.Response, mock.GetComponentStreamResponse.Error
}

type GetComponentStreamsMockResponse struct {
	Result   []TelemetryStreamDefinition
	Response *http.Response
	Error    error
}

type GetComponentStreamsCall struct {
	PcomponentId int64
	PqueryTime   *int32
}

func (mock ComponentApiMock) GetComponentStreams(ctx context.Context, componentId int64) ApiGetComponentStreamsRequest {
	return ApiGetComponentStreamsRequest{
		ApiService:  mock,
		ctx:         ctx,
		componentId: componentId,
	}
}

func (mock ComponentApiMock) GetComponentStreamsExecute(r ApiGetComponentStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error) {
	p := GetComponentStreamsCall{
		PcomponentId: r.componentId,
		PqueryTime:   r.queryTime,
	}
	*mock.GetComponentStreamsCalls = append(*mock.GetComponentStreamsCalls, p)
	return mock.GetComponentStreamsResponse.Result, mock.GetComponentStreamsResponse.Response, mock.GetComponentStreamsResponse.Error
}

type GetLatestMetricsMockResponse struct {
	Result   TelemetryLatestSnapshotsResponse
	Response *http.Response
	Error    error
}

type GetLatestMetricsCall struct {
	PcomponentId int64
	PqueryTime   *int32
	PstreamIds   *[]int64
}

func (mock ComponentApiMock) GetLatestMetrics(ctx context.Context, componentId int64) ApiGetLatestMetricsRequest {
	return ApiGetLatestMetricsRequest{
		ApiService:  mock,
		ctx:         ctx,
		componentId: componentId,
	}
}

func (mock ComponentApiMock) GetLatestMetricsExecute(r ApiGetLatestMetricsRequest) (*TelemetryLatestSnapshotsResponse, *http.Response, error) {
	p := GetLatestMetricsCall{
		PcomponentId: r.componentId,
		PqueryTime:   r.queryTime,
		PstreamIds:   r.streamIds,
	}
	*mock.GetLatestMetricsCalls = append(*mock.GetLatestMetricsCalls, p)
	return &mock.GetLatestMetricsResponse.Result, mock.GetLatestMetricsResponse.Response, mock.GetLatestMetricsResponse.Error
}
