/*
StackState API

StackState's API specification

API version: 0.0.1
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type RelationApi interface {

	/*
	CreateRelationCheck Create the Checks on the relation

	Adds a Check on the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@return ApiCreateRelationCheckRequest
	*/
	CreateRelationCheck(ctx context.Context, relationId int64) ApiCreateRelationCheckRequest

	// CreateRelationCheckExecute executes the request
	//  @return Check
	CreateRelationCheckExecute(r ApiCreateRelationCheckRequest) (*Check, *http.Response, error)

	/*
	CreateRelationStream Create the Stream on the relation

	Adds a DataStream/TelemetryStreamDefinition on the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@return ApiCreateRelationStreamRequest
	*/
	CreateRelationStream(ctx context.Context, relationId int64) ApiCreateRelationStreamRequest

	// CreateRelationStreamExecute executes the request
	//  @return TelemetryStreamDefinition
	CreateRelationStreamExecute(r ApiCreateRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error)

	/*
	DeleteRelationCheck Delete the check from the relation

	Delete a Specific check from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@param checkId The Identifier of a Check
	@return ApiDeleteRelationCheckRequest
	*/
	DeleteRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiDeleteRelationCheckRequest

	// DeleteRelationCheckExecute executes the request
	DeleteRelationCheckExecute(r ApiDeleteRelationCheckRequest) (*http.Response, error)

	/*
	DeleteRelationStream Delete the stream from the relation

	Delete a Specific stream from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@param streamId The Identifier of a stream
	@return ApiDeleteRelationStreamRequest
	*/
	DeleteRelationStream(ctx context.Context, relationId int64, streamId int64) ApiDeleteRelationStreamRequest

	// DeleteRelationStreamExecute executes the request
	DeleteRelationStreamExecute(r ApiDeleteRelationStreamRequest) (*http.Response, error)

	/*
	GetRelationCheck Get the check from the relation

	Get a Specific check from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@param checkId The Identifier of a Check
	@return ApiGetRelationCheckRequest
	*/
	GetRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiGetRelationCheckRequest

	// GetRelationCheckExecute executes the request
	//  @return Check
	GetRelationCheckExecute(r ApiGetRelationCheckRequest) (*Check, *http.Response, error)

	/*
	GetRelationChecks List all checks from the relation

	List all checks from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@return ApiGetRelationChecksRequest
	*/
	GetRelationChecks(ctx context.Context, relationId int64) ApiGetRelationChecksRequest

	// GetRelationChecksExecute executes the request
	//  @return []Check
	GetRelationChecksExecute(r ApiGetRelationChecksRequest) ([]Check, *http.Response, error)

	/*
	GetRelationStream Get the stream from the relation

	Get a Specific stream from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@param streamId The Identifier of a stream
	@return ApiGetRelationStreamRequest
	*/
	GetRelationStream(ctx context.Context, relationId int64, streamId int64) ApiGetRelationStreamRequest

	// GetRelationStreamExecute executes the request
	//  @return TelemetryStreamDefinition
	GetRelationStreamExecute(r ApiGetRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error)

	/*
	GetRelationStreams List all streams from the relation

	List all streams from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@return ApiGetRelationStreamsRequest
	*/
	GetRelationStreams(ctx context.Context, relationId int64) ApiGetRelationStreamsRequest

	// GetRelationStreamsExecute executes the request
	//  @return []TelemetryStreamDefinition
	GetRelationStreamsExecute(r ApiGetRelationStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error)

	/*
	PutRelationCheck Update the check on the relation

	Update a Specific check from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@param checkId The Identifier of a Check
	@return ApiPutRelationCheckRequest
	*/
	PutRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiPutRelationCheckRequest

	// PutRelationCheckExecute executes the request
	//  @return Check
	PutRelationCheckExecute(r ApiPutRelationCheckRequest) (*Check, *http.Response, error)

	/*
	PutRelationStream Update the stream on the relation

	Update a Specific stream from the relation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param relationId The Identifier of a relation
	@param streamId The Identifier of a stream
	@return ApiPutRelationStreamRequest
	*/
	PutRelationStream(ctx context.Context, relationId int64, streamId int64) ApiPutRelationStreamRequest

	// PutRelationStreamExecute executes the request
	//  @return TelemetryStreamDefinition
	PutRelationStreamExecute(r ApiPutRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error)
}

// RelationApiService RelationApi service
type RelationApiService service

type ApiCreateRelationCheckRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	check *Check
}

// Single Check
func (r ApiCreateRelationCheckRequest) Check(check Check) ApiCreateRelationCheckRequest {
	r.check = &check
	return r
}

func (r ApiCreateRelationCheckRequest) Execute() (*Check, *http.Response, error) {
	return r.ApiService.CreateRelationCheckExecute(r)
}

/*
CreateRelationCheck Create the Checks on the relation

Adds a Check on the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @return ApiCreateRelationCheckRequest
*/
func (a *RelationApiService) CreateRelationCheck(ctx context.Context, relationId int64) ApiCreateRelationCheckRequest {
	return ApiCreateRelationCheckRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return Check
func (a *RelationApiService) CreateRelationCheckExecute(r ApiCreateRelationCheckRequest) (*Check, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.CreateRelationCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/checks"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.check == nil {
		return localVarReturnValue, nil, reportError("check is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.check
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRelationStreamRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	dataStream *DataStream
}

// Single telemetry stream definition
func (r ApiCreateRelationStreamRequest) DataStream(dataStream DataStream) ApiCreateRelationStreamRequest {
	r.dataStream = &dataStream
	return r
}

func (r ApiCreateRelationStreamRequest) Execute() (*TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.CreateRelationStreamExecute(r)
}

/*
CreateRelationStream Create the Stream on the relation

Adds a DataStream/TelemetryStreamDefinition on the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @return ApiCreateRelationStreamRequest
*/
func (a *RelationApiService) CreateRelationStream(ctx context.Context, relationId int64) ApiCreateRelationStreamRequest {
	return ApiCreateRelationStreamRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return TelemetryStreamDefinition
func (a *RelationApiService) CreateRelationStreamExecute(r ApiCreateRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.CreateRelationStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/streams"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataStream == nil {
		return localVarReturnValue, nil, reportError("dataStream is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataStream
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRelationCheckRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	checkId int64
}

func (r ApiDeleteRelationCheckRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRelationCheckExecute(r)
}

/*
DeleteRelationCheck Delete the check from the relation

Delete a Specific check from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param checkId The Identifier of a Check
 @return ApiDeleteRelationCheckRequest
*/
func (a *RelationApiService) DeleteRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiDeleteRelationCheckRequest {
	return ApiDeleteRelationCheckRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
		checkId: checkId,
	}
}

// Execute executes the request
func (a *RelationApiService) DeleteRelationCheckExecute(r ApiDeleteRelationCheckRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.DeleteRelationCheck")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/checks/{checkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"checkId"+"}", url.PathEscape(parameterToString(r.checkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRelationStreamRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	streamId int64
}

func (r ApiDeleteRelationStreamRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRelationStreamExecute(r)
}

/*
DeleteRelationStream Delete the stream from the relation

Delete a Specific stream from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param streamId The Identifier of a stream
 @return ApiDeleteRelationStreamRequest
*/
func (a *RelationApiService) DeleteRelationStream(ctx context.Context, relationId int64, streamId int64) ApiDeleteRelationStreamRequest {
	return ApiDeleteRelationStreamRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
		streamId: streamId,
	}
}

// Execute executes the request
func (a *RelationApiService) DeleteRelationStreamExecute(r ApiDeleteRelationStreamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.DeleteRelationStream")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/streams/{streamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRelationCheckRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	queryTime *int32
	checkId int64
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationCheckRequest) QueryTime(queryTime int32) ApiGetRelationCheckRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationCheckRequest) Execute() (*Check, *http.Response, error) {
	return r.ApiService.GetRelationCheckExecute(r)
}

/*
GetRelationCheck Get the check from the relation

Get a Specific check from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param checkId The Identifier of a Check
 @return ApiGetRelationCheckRequest
*/
func (a *RelationApiService) GetRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiGetRelationCheckRequest {
	return ApiGetRelationCheckRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
		checkId: checkId,
	}
}

// Execute executes the request
//  @return Check
func (a *RelationApiService) GetRelationCheckExecute(r ApiGetRelationCheckRequest) (*Check, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/checks/{checkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"checkId"+"}", url.PathEscape(parameterToString(r.checkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRelationChecksRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	queryTime *int32
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationChecksRequest) QueryTime(queryTime int32) ApiGetRelationChecksRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationChecksRequest) Execute() ([]Check, *http.Response, error) {
	return r.ApiService.GetRelationChecksExecute(r)
}

/*
GetRelationChecks List all checks from the relation

List all checks from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @return ApiGetRelationChecksRequest
*/
func (a *RelationApiService) GetRelationChecks(ctx context.Context, relationId int64) ApiGetRelationChecksRequest {
	return ApiGetRelationChecksRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return []Check
func (a *RelationApiService) GetRelationChecksExecute(r ApiGetRelationChecksRequest) ([]Check, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/checks"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRelationStreamRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	queryTime *int32
	streamId int64
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationStreamRequest) QueryTime(queryTime int32) ApiGetRelationStreamRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationStreamRequest) Execute() (*TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.GetRelationStreamExecute(r)
}

/*
GetRelationStream Get the stream from the relation

Get a Specific stream from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param streamId The Identifier of a stream
 @return ApiGetRelationStreamRequest
*/
func (a *RelationApiService) GetRelationStream(ctx context.Context, relationId int64, streamId int64) ApiGetRelationStreamRequest {
	return ApiGetRelationStreamRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
		streamId: streamId,
	}
}

// Execute executes the request
//  @return TelemetryStreamDefinition
func (a *RelationApiService) GetRelationStreamExecute(r ApiGetRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/streams/{streamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRelationStreamsRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	queryTime *int32
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationStreamsRequest) QueryTime(queryTime int32) ApiGetRelationStreamsRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationStreamsRequest) Execute() ([]TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.GetRelationStreamsExecute(r)
}

/*
GetRelationStreams List all streams from the relation

List all streams from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @return ApiGetRelationStreamsRequest
*/
func (a *RelationApiService) GetRelationStreams(ctx context.Context, relationId int64) ApiGetRelationStreamsRequest {
	return ApiGetRelationStreamsRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return []TelemetryStreamDefinition
func (a *RelationApiService) GetRelationStreamsExecute(r ApiGetRelationStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationStreams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/streams"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRelationCheckRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	checkId int64
	check *Check
}

// Single Check
func (r ApiPutRelationCheckRequest) Check(check Check) ApiPutRelationCheckRequest {
	r.check = &check
	return r
}

func (r ApiPutRelationCheckRequest) Execute() (*Check, *http.Response, error) {
	return r.ApiService.PutRelationCheckExecute(r)
}

/*
PutRelationCheck Update the check on the relation

Update a Specific check from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param checkId The Identifier of a Check
 @return ApiPutRelationCheckRequest
*/
func (a *RelationApiService) PutRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiPutRelationCheckRequest {
	return ApiPutRelationCheckRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
		checkId: checkId,
	}
}

// Execute executes the request
//  @return Check
func (a *RelationApiService) PutRelationCheckExecute(r ApiPutRelationCheckRequest) (*Check, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.PutRelationCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/checks/{checkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"checkId"+"}", url.PathEscape(parameterToString(r.checkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.check == nil {
		return localVarReturnValue, nil, reportError("check is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.check
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRelationStreamRequest struct {
	ctx context.Context
	ApiService RelationApi
	relationId int64
	streamId int64
	dataStream *DataStream
}

// Single telemetry stream definition
func (r ApiPutRelationStreamRequest) DataStream(dataStream DataStream) ApiPutRelationStreamRequest {
	r.dataStream = &dataStream
	return r
}

func (r ApiPutRelationStreamRequest) Execute() (*TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.PutRelationStreamExecute(r)
}

/*
PutRelationStream Update the stream on the relation

Update a Specific stream from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param streamId The Identifier of a stream
 @return ApiPutRelationStreamRequest
*/
func (a *RelationApiService) PutRelationStream(ctx context.Context, relationId int64, streamId int64) ApiPutRelationStreamRequest {
	return ApiPutRelationStreamRequest{
		ApiService: a,
		ctx: ctx,
		relationId: relationId,
		streamId: streamId,
	}
}

// Execute executes the request
//  @return TelemetryStreamDefinition
func (a *RelationApiService) PutRelationStreamExecute(r ApiPutRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.PutRelationStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/streams/{streamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataStream == nil {
		return localVarReturnValue, nil, reportError("dataStream is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataStream
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}


// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------


type RelationApiMock struct {
	CreateRelationCheckCalls *[]CreateRelationCheckCall
	CreateRelationCheckResponse CreateRelationCheckMockResponse
	CreateRelationStreamCalls *[]CreateRelationStreamCall
	CreateRelationStreamResponse CreateRelationStreamMockResponse
	DeleteRelationCheckCalls *[]DeleteRelationCheckCall
	DeleteRelationCheckResponse DeleteRelationCheckMockResponse
	DeleteRelationStreamCalls *[]DeleteRelationStreamCall
	DeleteRelationStreamResponse DeleteRelationStreamMockResponse
	GetRelationCheckCalls *[]GetRelationCheckCall
	GetRelationCheckResponse GetRelationCheckMockResponse
	GetRelationChecksCalls *[]GetRelationChecksCall
	GetRelationChecksResponse GetRelationChecksMockResponse
	GetRelationStreamCalls *[]GetRelationStreamCall
	GetRelationStreamResponse GetRelationStreamMockResponse
	GetRelationStreamsCalls *[]GetRelationStreamsCall
	GetRelationStreamsResponse GetRelationStreamsMockResponse
	PutRelationCheckCalls *[]PutRelationCheckCall
	PutRelationCheckResponse PutRelationCheckMockResponse
	PutRelationStreamCalls *[]PutRelationStreamCall
	PutRelationStreamResponse PutRelationStreamMockResponse
}	

func NewRelationApiMock() RelationApiMock {
	xCreateRelationCheckCalls := make([]CreateRelationCheckCall, 0)
	xCreateRelationStreamCalls := make([]CreateRelationStreamCall, 0)
	xDeleteRelationCheckCalls := make([]DeleteRelationCheckCall, 0)
	xDeleteRelationStreamCalls := make([]DeleteRelationStreamCall, 0)
	xGetRelationCheckCalls := make([]GetRelationCheckCall, 0)
	xGetRelationChecksCalls := make([]GetRelationChecksCall, 0)
	xGetRelationStreamCalls := make([]GetRelationStreamCall, 0)
	xGetRelationStreamsCalls := make([]GetRelationStreamsCall, 0)
	xPutRelationCheckCalls := make([]PutRelationCheckCall, 0)
	xPutRelationStreamCalls := make([]PutRelationStreamCall, 0)
	return RelationApiMock {
		CreateRelationCheckCalls: &xCreateRelationCheckCalls,
		CreateRelationStreamCalls: &xCreateRelationStreamCalls,
		DeleteRelationCheckCalls: &xDeleteRelationCheckCalls,
		DeleteRelationStreamCalls: &xDeleteRelationStreamCalls,
		GetRelationCheckCalls: &xGetRelationCheckCalls,
		GetRelationChecksCalls: &xGetRelationChecksCalls,
		GetRelationStreamCalls: &xGetRelationStreamCalls,
		GetRelationStreamsCalls: &xGetRelationStreamsCalls,
		PutRelationCheckCalls: &xPutRelationCheckCalls,
		PutRelationStreamCalls: &xPutRelationStreamCalls,
	}
}

type CreateRelationCheckMockResponse struct {
	Result Check
	Response *http.Response
	Error error
}

type CreateRelationCheckCall struct {
	PrelationId int64
	Pcheck *Check
}


func (mock RelationApiMock) CreateRelationCheck(ctx context.Context, relationId int64) ApiCreateRelationCheckRequest {
	return ApiCreateRelationCheckRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
	}
}

func (mock RelationApiMock) CreateRelationCheckExecute(r ApiCreateRelationCheckRequest) (*Check, *http.Response, error) {
	p := CreateRelationCheckCall {
			PrelationId: r.relationId,
			Pcheck: r.check,
	}
	*mock.CreateRelationCheckCalls = append(*mock.CreateRelationCheckCalls, p)
	return &mock.CreateRelationCheckResponse.Result, mock.CreateRelationCheckResponse.Response, mock.CreateRelationCheckResponse.Error
}

type CreateRelationStreamMockResponse struct {
	Result TelemetryStreamDefinition
	Response *http.Response
	Error error
}

type CreateRelationStreamCall struct {
	PrelationId int64
	PdataStream *DataStream
}


func (mock RelationApiMock) CreateRelationStream(ctx context.Context, relationId int64) ApiCreateRelationStreamRequest {
	return ApiCreateRelationStreamRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
	}
}

func (mock RelationApiMock) CreateRelationStreamExecute(r ApiCreateRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	p := CreateRelationStreamCall {
			PrelationId: r.relationId,
			PdataStream: r.dataStream,
	}
	*mock.CreateRelationStreamCalls = append(*mock.CreateRelationStreamCalls, p)
	return &mock.CreateRelationStreamResponse.Result, mock.CreateRelationStreamResponse.Response, mock.CreateRelationStreamResponse.Error
}

type DeleteRelationCheckMockResponse struct {
	
	Response *http.Response
	Error error
}

type DeleteRelationCheckCall struct {
	PrelationId int64
	PcheckId int64
}


func (mock RelationApiMock) DeleteRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiDeleteRelationCheckRequest {
	return ApiDeleteRelationCheckRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
		checkId: checkId,
	}
}

func (mock RelationApiMock) DeleteRelationCheckExecute(r ApiDeleteRelationCheckRequest) (*http.Response, error) {
	p := DeleteRelationCheckCall {
			PrelationId: r.relationId,
			PcheckId: r.checkId,
	}
	*mock.DeleteRelationCheckCalls = append(*mock.DeleteRelationCheckCalls, p)
	return mock.DeleteRelationCheckResponse.Response, mock.DeleteRelationCheckResponse.Error
}

type DeleteRelationStreamMockResponse struct {
	
	Response *http.Response
	Error error
}

type DeleteRelationStreamCall struct {
	PrelationId int64
	PstreamId int64
}


func (mock RelationApiMock) DeleteRelationStream(ctx context.Context, relationId int64, streamId int64) ApiDeleteRelationStreamRequest {
	return ApiDeleteRelationStreamRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
		streamId: streamId,
	}
}

func (mock RelationApiMock) DeleteRelationStreamExecute(r ApiDeleteRelationStreamRequest) (*http.Response, error) {
	p := DeleteRelationStreamCall {
			PrelationId: r.relationId,
			PstreamId: r.streamId,
	}
	*mock.DeleteRelationStreamCalls = append(*mock.DeleteRelationStreamCalls, p)
	return mock.DeleteRelationStreamResponse.Response, mock.DeleteRelationStreamResponse.Error
}

type GetRelationCheckMockResponse struct {
	Result Check
	Response *http.Response
	Error error
}

type GetRelationCheckCall struct {
	PrelationId int64
	PqueryTime *int32
	PcheckId int64
}


func (mock RelationApiMock) GetRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiGetRelationCheckRequest {
	return ApiGetRelationCheckRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
		checkId: checkId,
	}
}

func (mock RelationApiMock) GetRelationCheckExecute(r ApiGetRelationCheckRequest) (*Check, *http.Response, error) {
	p := GetRelationCheckCall {
			PrelationId: r.relationId,
			PqueryTime: r.queryTime,
			PcheckId: r.checkId,
	}
	*mock.GetRelationCheckCalls = append(*mock.GetRelationCheckCalls, p)
	return &mock.GetRelationCheckResponse.Result, mock.GetRelationCheckResponse.Response, mock.GetRelationCheckResponse.Error
}

type GetRelationChecksMockResponse struct {
	Result []Check
	Response *http.Response
	Error error
}

type GetRelationChecksCall struct {
	PrelationId int64
	PqueryTime *int32
}


func (mock RelationApiMock) GetRelationChecks(ctx context.Context, relationId int64) ApiGetRelationChecksRequest {
	return ApiGetRelationChecksRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
	}
}

func (mock RelationApiMock) GetRelationChecksExecute(r ApiGetRelationChecksRequest) ([]Check, *http.Response, error) {
	p := GetRelationChecksCall {
			PrelationId: r.relationId,
			PqueryTime: r.queryTime,
	}
	*mock.GetRelationChecksCalls = append(*mock.GetRelationChecksCalls, p)
	return mock.GetRelationChecksResponse.Result, mock.GetRelationChecksResponse.Response, mock.GetRelationChecksResponse.Error
}

type GetRelationStreamMockResponse struct {
	Result TelemetryStreamDefinition
	Response *http.Response
	Error error
}

type GetRelationStreamCall struct {
	PrelationId int64
	PqueryTime *int32
	PstreamId int64
}


func (mock RelationApiMock) GetRelationStream(ctx context.Context, relationId int64, streamId int64) ApiGetRelationStreamRequest {
	return ApiGetRelationStreamRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
		streamId: streamId,
	}
}

func (mock RelationApiMock) GetRelationStreamExecute(r ApiGetRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	p := GetRelationStreamCall {
			PrelationId: r.relationId,
			PqueryTime: r.queryTime,
			PstreamId: r.streamId,
	}
	*mock.GetRelationStreamCalls = append(*mock.GetRelationStreamCalls, p)
	return &mock.GetRelationStreamResponse.Result, mock.GetRelationStreamResponse.Response, mock.GetRelationStreamResponse.Error
}

type GetRelationStreamsMockResponse struct {
	Result []TelemetryStreamDefinition
	Response *http.Response
	Error error
}

type GetRelationStreamsCall struct {
	PrelationId int64
	PqueryTime *int32
}


func (mock RelationApiMock) GetRelationStreams(ctx context.Context, relationId int64) ApiGetRelationStreamsRequest {
	return ApiGetRelationStreamsRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
	}
}

func (mock RelationApiMock) GetRelationStreamsExecute(r ApiGetRelationStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error) {
	p := GetRelationStreamsCall {
			PrelationId: r.relationId,
			PqueryTime: r.queryTime,
	}
	*mock.GetRelationStreamsCalls = append(*mock.GetRelationStreamsCalls, p)
	return mock.GetRelationStreamsResponse.Result, mock.GetRelationStreamsResponse.Response, mock.GetRelationStreamsResponse.Error
}

type PutRelationCheckMockResponse struct {
	Result Check
	Response *http.Response
	Error error
}

type PutRelationCheckCall struct {
	PrelationId int64
	PcheckId int64
	Pcheck *Check
}


func (mock RelationApiMock) PutRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiPutRelationCheckRequest {
	return ApiPutRelationCheckRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
		checkId: checkId,
	}
}

func (mock RelationApiMock) PutRelationCheckExecute(r ApiPutRelationCheckRequest) (*Check, *http.Response, error) {
	p := PutRelationCheckCall {
			PrelationId: r.relationId,
			PcheckId: r.checkId,
			Pcheck: r.check,
	}
	*mock.PutRelationCheckCalls = append(*mock.PutRelationCheckCalls, p)
	return &mock.PutRelationCheckResponse.Result, mock.PutRelationCheckResponse.Response, mock.PutRelationCheckResponse.Error
}

type PutRelationStreamMockResponse struct {
	Result TelemetryStreamDefinition
	Response *http.Response
	Error error
}

type PutRelationStreamCall struct {
	PrelationId int64
	PstreamId int64
	PdataStream *DataStream
}


func (mock RelationApiMock) PutRelationStream(ctx context.Context, relationId int64, streamId int64) ApiPutRelationStreamRequest {
	return ApiPutRelationStreamRequest{
		ApiService: mock,
		ctx: ctx,
		relationId: relationId,
		streamId: streamId,
	}
}

func (mock RelationApiMock) PutRelationStreamExecute(r ApiPutRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	p := PutRelationStreamCall {
			PrelationId: r.relationId,
			PstreamId: r.streamId,
			PdataStream: r.dataStream,
	}
	*mock.PutRelationStreamCalls = append(*mock.PutRelationStreamCalls, p)
	return &mock.PutRelationStreamResponse.Result, mock.PutRelationStreamResponse.Response, mock.PutRelationStreamResponse.Error
}


