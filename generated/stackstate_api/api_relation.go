/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type RelationApi interface {

	/*
		GetRelationCheck Get the check from the relation

		Get a Specific check from the relation

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param relationId The Identifier of a relation
		@param checkId The Identifier of a Check
		@return ApiGetRelationCheckRequest
	*/
	GetRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiGetRelationCheckRequest

	// GetRelationCheckExecute executes the request
	//  @return Check
	GetRelationCheckExecute(r ApiGetRelationCheckRequest) (*Check, *http.Response, error)

	/*
		GetRelationChecks List all checks from the relation

		List all checks from the relation

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param relationId The Identifier of a relation
		@return ApiGetRelationChecksRequest
	*/
	GetRelationChecks(ctx context.Context, relationId int64) ApiGetRelationChecksRequest

	// GetRelationChecksExecute executes the request
	//  @return []Check
	GetRelationChecksExecute(r ApiGetRelationChecksRequest) ([]Check, *http.Response, error)

	/*
		GetRelationStream Get the stream from the relation

		Get a Specific stream from the relation

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param relationId The Identifier of a relation
		@param streamId The Identifier of a stream
		@return ApiGetRelationStreamRequest
	*/
	GetRelationStream(ctx context.Context, relationId int64, streamId int64) ApiGetRelationStreamRequest

	// GetRelationStreamExecute executes the request
	//  @return TelemetryStreamDefinition
	GetRelationStreamExecute(r ApiGetRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error)

	/*
		GetRelationStreams List all streams from the relation

		List all streams from the relation

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param relationId The Identifier of a relation
		@return ApiGetRelationStreamsRequest
	*/
	GetRelationStreams(ctx context.Context, relationId int64) ApiGetRelationStreamsRequest

	// GetRelationStreamsExecute executes the request
	//  @return []TelemetryStreamDefinition
	GetRelationStreamsExecute(r ApiGetRelationStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error)
}

// RelationApiService RelationApi service
type RelationApiService service

type ApiGetRelationCheckRequest struct {
	ctx        context.Context
	ApiService RelationApi
	relationId int64
	queryTime  *int32
	checkId    int64
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationCheckRequest) QueryTime(queryTime int32) ApiGetRelationCheckRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationCheckRequest) Execute() (*Check, *http.Response, error) {
	return r.ApiService.GetRelationCheckExecute(r)
}

/*
GetRelationCheck Get the check from the relation

Get a Specific check from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param checkId The Identifier of a Check
 @return ApiGetRelationCheckRequest
*/
func (a *RelationApiService) GetRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiGetRelationCheckRequest {
	return ApiGetRelationCheckRequest{
		ApiService: a,
		ctx:        ctx,
		relationId: relationId,
		checkId:    checkId,
	}
}

// Execute executes the request
//  @return Check
func (a *RelationApiService) GetRelationCheckExecute(r ApiGetRelationCheckRequest) (*Check, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/checks/{checkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"checkId"+"}", url.PathEscape(parameterToString(r.checkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRelationChecksRequest struct {
	ctx        context.Context
	ApiService RelationApi
	relationId int64
	queryTime  *int32
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationChecksRequest) QueryTime(queryTime int32) ApiGetRelationChecksRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationChecksRequest) Execute() ([]Check, *http.Response, error) {
	return r.ApiService.GetRelationChecksExecute(r)
}

/*
GetRelationChecks List all checks from the relation

List all checks from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @return ApiGetRelationChecksRequest
*/
func (a *RelationApiService) GetRelationChecks(ctx context.Context, relationId int64) ApiGetRelationChecksRequest {
	return ApiGetRelationChecksRequest{
		ApiService: a,
		ctx:        ctx,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return []Check
func (a *RelationApiService) GetRelationChecksExecute(r ApiGetRelationChecksRequest) ([]Check, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Check
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/checks"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRelationStreamRequest struct {
	ctx        context.Context
	ApiService RelationApi
	relationId int64
	queryTime  *int32
	streamId   int64
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationStreamRequest) QueryTime(queryTime int32) ApiGetRelationStreamRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationStreamRequest) Execute() (*TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.GetRelationStreamExecute(r)
}

/*
GetRelationStream Get the stream from the relation

Get a Specific stream from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @param streamId The Identifier of a stream
 @return ApiGetRelationStreamRequest
*/
func (a *RelationApiService) GetRelationStream(ctx context.Context, relationId int64, streamId int64) ApiGetRelationStreamRequest {
	return ApiGetRelationStreamRequest{
		ApiService: a,
		ctx:        ctx,
		relationId: relationId,
		streamId:   streamId,
	}
}

// Execute executes the request
//  @return TelemetryStreamDefinition
func (a *RelationApiService) GetRelationStreamExecute(r ApiGetRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/streams/{streamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRelationStreamsRequest struct {
	ctx        context.Context
	ApiService RelationApi
	relationId int64
	queryTime  *int32
}

// A Data point for a query either point from timeline or &#39;now&#39; if livemode
func (r ApiGetRelationStreamsRequest) QueryTime(queryTime int32) ApiGetRelationStreamsRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetRelationStreamsRequest) Execute() ([]TelemetryStreamDefinition, *http.Response, error) {
	return r.ApiService.GetRelationStreamsExecute(r)
}

/*
GetRelationStreams List all streams from the relation

List all streams from the relation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relationId The Identifier of a relation
 @return ApiGetRelationStreamsRequest
*/
func (a *RelationApiService) GetRelationStreams(ctx context.Context, relationId int64) ApiGetRelationStreamsRequest {
	return ApiGetRelationStreamsRequest{
		ApiService: a,
		ctx:        ctx,
		relationId: relationId,
	}
}

// Execute executes the request
//  @return []TelemetryStreamDefinition
func (a *RelationApiService) GetRelationStreamsExecute(r ApiGetRelationStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TelemetryStreamDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RelationApiService.GetRelationStreams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relations/{relationId}/streams"
	localVarPath = strings.Replace(localVarPath, "{"+"relationId"+"}", url.PathEscape(parameterToString(r.relationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryTime == nil {
		return localVarReturnValue, nil, reportError("queryTime is required and must be specified")
	}

	localVarQueryParams.Add("queryTime", parameterToString(*r.queryTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v StackElementNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type RelationApiMock struct {
	GetRelationCheckCalls      *[]GetRelationCheckCall
	GetRelationCheckResponse   GetRelationCheckMockResponse
	GetRelationChecksCalls     *[]GetRelationChecksCall
	GetRelationChecksResponse  GetRelationChecksMockResponse
	GetRelationStreamCalls     *[]GetRelationStreamCall
	GetRelationStreamResponse  GetRelationStreamMockResponse
	GetRelationStreamsCalls    *[]GetRelationStreamsCall
	GetRelationStreamsResponse GetRelationStreamsMockResponse
}

func NewRelationApiMock() RelationApiMock {
	xGetRelationCheckCalls := make([]GetRelationCheckCall, 0)
	xGetRelationChecksCalls := make([]GetRelationChecksCall, 0)
	xGetRelationStreamCalls := make([]GetRelationStreamCall, 0)
	xGetRelationStreamsCalls := make([]GetRelationStreamsCall, 0)
	return RelationApiMock{
		GetRelationCheckCalls:   &xGetRelationCheckCalls,
		GetRelationChecksCalls:  &xGetRelationChecksCalls,
		GetRelationStreamCalls:  &xGetRelationStreamCalls,
		GetRelationStreamsCalls: &xGetRelationStreamsCalls,
	}
}

type GetRelationCheckMockResponse struct {
	Result   Check
	Response *http.Response
	Error    error
}

type GetRelationCheckCall struct {
	PrelationId int64
	PqueryTime  *int32
	PcheckId    int64
}

func (mock RelationApiMock) GetRelationCheck(ctx context.Context, relationId int64, checkId int64) ApiGetRelationCheckRequest {
	return ApiGetRelationCheckRequest{
		ApiService: mock,
		ctx:        ctx,
		relationId: relationId,
		checkId:    checkId,
	}
}

func (mock RelationApiMock) GetRelationCheckExecute(r ApiGetRelationCheckRequest) (*Check, *http.Response, error) {
	p := GetRelationCheckCall{
		PrelationId: r.relationId,
		PqueryTime:  r.queryTime,
		PcheckId:    r.checkId,
	}
	*mock.GetRelationCheckCalls = append(*mock.GetRelationCheckCalls, p)
	return &mock.GetRelationCheckResponse.Result, mock.GetRelationCheckResponse.Response, mock.GetRelationCheckResponse.Error
}

type GetRelationChecksMockResponse struct {
	Result   []Check
	Response *http.Response
	Error    error
}

type GetRelationChecksCall struct {
	PrelationId int64
	PqueryTime  *int32
}

func (mock RelationApiMock) GetRelationChecks(ctx context.Context, relationId int64) ApiGetRelationChecksRequest {
	return ApiGetRelationChecksRequest{
		ApiService: mock,
		ctx:        ctx,
		relationId: relationId,
	}
}

func (mock RelationApiMock) GetRelationChecksExecute(r ApiGetRelationChecksRequest) ([]Check, *http.Response, error) {
	p := GetRelationChecksCall{
		PrelationId: r.relationId,
		PqueryTime:  r.queryTime,
	}
	*mock.GetRelationChecksCalls = append(*mock.GetRelationChecksCalls, p)
	return mock.GetRelationChecksResponse.Result, mock.GetRelationChecksResponse.Response, mock.GetRelationChecksResponse.Error
}

type GetRelationStreamMockResponse struct {
	Result   TelemetryStreamDefinition
	Response *http.Response
	Error    error
}

type GetRelationStreamCall struct {
	PrelationId int64
	PqueryTime  *int32
	PstreamId   int64
}

func (mock RelationApiMock) GetRelationStream(ctx context.Context, relationId int64, streamId int64) ApiGetRelationStreamRequest {
	return ApiGetRelationStreamRequest{
		ApiService: mock,
		ctx:        ctx,
		relationId: relationId,
		streamId:   streamId,
	}
}

func (mock RelationApiMock) GetRelationStreamExecute(r ApiGetRelationStreamRequest) (*TelemetryStreamDefinition, *http.Response, error) {
	p := GetRelationStreamCall{
		PrelationId: r.relationId,
		PqueryTime:  r.queryTime,
		PstreamId:   r.streamId,
	}
	*mock.GetRelationStreamCalls = append(*mock.GetRelationStreamCalls, p)
	return &mock.GetRelationStreamResponse.Result, mock.GetRelationStreamResponse.Response, mock.GetRelationStreamResponse.Error
}

type GetRelationStreamsMockResponse struct {
	Result   []TelemetryStreamDefinition
	Response *http.Response
	Error    error
}

type GetRelationStreamsCall struct {
	PrelationId int64
	PqueryTime  *int32
}

func (mock RelationApiMock) GetRelationStreams(ctx context.Context, relationId int64) ApiGetRelationStreamsRequest {
	return ApiGetRelationStreamsRequest{
		ApiService: mock,
		ctx:        ctx,
		relationId: relationId,
	}
}

func (mock RelationApiMock) GetRelationStreamsExecute(r ApiGetRelationStreamsRequest) ([]TelemetryStreamDefinition, *http.Response, error) {
	p := GetRelationStreamsCall{
		PrelationId: r.relationId,
		PqueryTime:  r.queryTime,
	}
	*mock.GetRelationStreamsCalls = append(*mock.GetRelationStreamsCalls, p)
	return mock.GetRelationStreamsResponse.Result, mock.GetRelationStreamsResponse.Response, mock.GetRelationStreamsResponse.Error
}
